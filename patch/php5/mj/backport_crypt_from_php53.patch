diff --git a/ext/standard/config.m4 b/ext/standard/config.m4
index 38602c0..4dc5e35 100644
--- a/ext/standard/config.m4
+++ b/ext/standard/config.m4
@@ -84,12 +84,6 @@ main() {
 ],[
   ac_cv_crypt_des=yes
 ])])
-if test "$ac_cv_crypt_des" = "yes"; then
-  ac_result=1
-else
-  ac_result=0
-fi
-AC_DEFINE_UNQUOTED(PHP_STD_DES_CRYPT, $ac_result, [Whether the system supports standard DES salt])
 
 AC_CACHE_CHECK(for extended DES crypt, ac_cv_crypt_ext_des,[
   AC_TRY_RUN([
@@ -114,12 +108,6 @@ main() {
 ],[
   ac_cv_crypt_ext_des=no
 ])])
-if test "$ac_cv_crypt_ext_des" = "yes"; then
-  ac_result=1
-else
-  ac_result=0
-fi
-AC_DEFINE_UNQUOTED(PHP_EXT_DES_CRYPT, $ac_result, [Whether the system supports extended DES salt])
 
 AC_CACHE_CHECK(for MD5 crypt, ac_cv_crypt_md5,[
 AC_TRY_RUN([
@@ -192,12 +180,171 @@ main() {
 ],[
   ac_cv_crypt_blowfish=no
 ])])
-if test "$ac_cv_crypt_blowfish" = "yes"; then
-  ac_result=1
-else
-  ac_result=0
+
+AC_CACHE_CHECK(for SHA512 crypt, ac_cv_crypt_SHA512,[
+AC_TRY_RUN([
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#if HAVE_CRYPT_H
+#include <crypt.h>
+#endif
+
+main() {
+#if HAVE_CRYPT
+    char salt[30], answer[80];
+    
+    salt[0]='$'; salt[1]='6'; salt[2]='$'; salt[3]='$'; salt[4]='b'; salt[5]='a'; salt[6]='r'; salt[7]='\0';
+    strcpy(answer, salt);
+    strcpy(&answer[29],"$6$$QMXjqd7rHQZPQ1yHsXkQqC1FBzDiVfTHXL.LaeDAeVV.IzMaV9VU4MQ8kPuZa2SOP1A0RPm772EaFYjpEJtdu.");
+    exit (strcmp((char *)crypt("foo",salt),answer));
+#else
+	exit(0);
+#endif
+}],[
+  ac_cv_crypt_SHA512=yes
+],[
+  ac_cv_crypt_SHA512=no
+],[
+  ac_cv_crypt_SHA512=no
+])])
+
+AC_CACHE_CHECK(for SHA256 crypt, ac_cv_crypt_SHA256,[
+AC_TRY_RUN([
+#if HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+
+#if HAVE_CRYPT_H
+#include <crypt.h>
+#endif
+
+main() {
+#if HAVE_CRYPT
+    char salt[30], answer[80];
+    salt[0]='$'; salt[1]='5'; salt[2]='$'; salt[3]='$'; salt[4]='s'; salt[5]='a'; salt[6]='l'; salt[7]='t';  salt[8]='s'; salt[9]='t'; salt[10]='r'; salt[11]='i'; salt[12]='n'; salt[13]='g'; salt[14]='\0';    
+    strcat(salt,"");
+    strcpy(answer, salt);
+    strcpy(&answer[29], "$5$saltstring$5B8vYYiY.CVt1RlTTf8KbXBH3hsxY/GNooZaBBGWEc5");
+    exit (strcmp((char *)crypt("foo",salt),answer));
+#else
+	exit(0);
+#endif
+}],[
+  ac_cv_crypt_SHA256=yes
+],[
+  ac_cv_crypt_SHA256=no
+],[
+  ac_cv_crypt_SHA256=no
+])])
+
+
+dnl
+dnl If one of them is missing, use our own implementation, portable code is then possible
+dnl
+if test "$ac_cv_crypt_blowfish" = "no" || test "$ac_cv_crypt_des" = "no" || test "$ac_cv_crypt_ext_des" = "no" || test "x$php_crypt_r" = "x0"; then
+
+  dnl
+  dnl Check for __alignof__ support in the compiler
+  dnl
+  AC_CACHE_CHECK(whether the compiler supports __alignof__, ac_cv_alignof_exists,[
+  AC_TRY_COMPILE([
+  ],[
+    int align = __alignof__(int);
+  ],[
+    ac_cv_alignof_exists=yes
+  ],[
+    ac_cv_alignof_exists=no
+  ])])
+  if test "$ac_cv_alignof_exists" = "yes"; then
+    AC_DEFINE([HAVE_ALIGNOF], 1, [whether the compiler supports __alignof__])
+  fi
+
+  dnl 
+  dnl Check for __attribute__ ((__aligned__)) support in the compiler
+  dnl
+  AC_CACHE_CHECK(whether the compiler supports aligned attribute, ac_cv_attribute_aligned,[
+  AC_TRY_COMPILE([
+  ],[
+    unsigned char test[32] __attribute__ ((__aligned__ (__alignof__ (int))));
+  ],[
+    ac_cv_attribute_aligned=yes
+  ],[
+    ac_cv_attribute_aligned=no
+  ])])
+  if test "$ac_cv_attribute_aligned" = "yes"; then
+    AC_DEFINE([HAVE_ATTRIBUTE_ALIGNED], 1, [whether the compiler supports __attribute__ ((__aligned__))])
+  fi
+    
+
+  AC_DEFINE_UNQUOTED(PHP_USE_PHP_CRYPT_R, 1, [Whether PHP has to use its own crypt_r for blowfish, des, ext des and md5])
+  AC_DEFINE_UNQUOTED(PHP_STD_DES_CRYPT, 1, [Whether the system supports standard DES salt])
+  AC_DEFINE_UNQUOTED(PHP_BLOWFISH_CRYPT, 1, [Whether the system supports BlowFish salt])
+  AC_DEFINE_UNQUOTED(PHP_EXT_DES_CRYPT, 1, [Whether the system supports extended DES salt])
+  AC_DEFINE_UNQUOTED(PHP_MD5_CRYPT, 1, [Whether the system supports MD5 salt])
+  AC_DEFINE_UNQUOTED(PHP_SHA512_CRYPT, 1, [Whether the system supports SHA512 salt])
+  AC_DEFINE_UNQUOTED(PHP_SHA256_CRYPT, 1, [Whether the system supports SHA256 salt])
+
+  PHP_ADD_SOURCES(PHP_EXT_DIR(standard), crypt_freesec.c crypt_blowfish.c crypt_sha512.c crypt_sha256.c php_crypt_r.c)
+ else
+  if test "$ac_cv_crypt_des" = "yes"; then
+    ac_result=1
+    ac_crypt_des=1
+  else
+    ac_result=0
+    ac_crypt_des=0
+  fi
+  AC_DEFINE_UNQUOTED(PHP_STD_DES_CRYPT, $ac_result, [Whether the system supports standard DES salt])
+
+  if test "$ac_cv_crypt_blowfish" = "yes"; then
+    ac_result=1
+    ac_crypt_blowfish=1
+  else
+    ac_result=0
+    ac_crypt_blowfish=0
+  fi
+  AC_DEFINE_UNQUOTED(PHP_BLOWFISH_CRYPT, $ac_result, [Whether the system supports BlowFish salt])
+
+  if test "$ac_cv_crypt_ext_des" = "yes"; then
+    ac_result=1
+    ac_crypt_edes=1
+  else
+    ac_result=0
+    ac_crypt_edes=0
+  fi
+  AC_DEFINE_UNQUOTED(PHP_EXT_DES_CRYPT, $ac_result, [Whether the system supports extended DES salt])
+
+  if test "$ac_cv_crypt_md5" = "yes"; then
+    ac_result=1
+    ac_crypt_md5=1
+  else
+    ac_result=0
+    ac_crypt_md5=0
+  fi
+  AC_DEFINE_UNQUOTED(PHP_MD5_CRYPT, $ac_result, [Whether the system supports MD5 salt])  
+  
+  if test "$ac_cv_crypt_sha512" = "yes"; then
+    ac_result=1
+    ac_crypt_sha512=1
+  else
+    ac_result=0
+    ac_crypt_sha512=0
+  fi
+  AC_DEFINE_UNQUOTED(PHP_SHA512_CRYPT, $ac_result, [Whether the system supports SHA512 salt])
+
+  if test "$ac_cv_crypt_sha256" = "yes"; then
+    ac_result=1
+    ac_crypt_sha256=1
+  else
+    ac_result=0
+    ac_crypt_sha256=0
+  fi
+  AC_DEFINE_UNQUOTED(PHP_SHA256_CRYPT, $ac_result, [Whether the system supports SHA256 salt])
+
+  AC_DEFINE_UNQUOTED(PHP_USE_PHP_CRYPT_R, 0, [Whether PHP has to use its own crypt_r for blowfish, des and ext des])
+
 fi
-AC_DEFINE_UNQUOTED(PHP_BLOWFISH_CRYPT, $ac_result, [Whether the system supports BlowFish salt])
 
 dnl
 dnl Check for available functions
@@ -525,7 +672,8 @@ PHP_NEW_EXTENSION(standard, array.c base64.c basic_functions.c browscap.c crc32.
                             incomplete_class.c url_scanner_ex.c ftp_fopen_wrapper.c \
                             http_fopen_wrapper.c php_fopen_wrapper.c credits.c css.c \
                             var_unserializer.c ftok.c sha1.c user_filters.c uuencode.c \
-                            filters.c proc_open.c streamsfuncs.c http.c)
+                            filters.c proc_open.c streamsfuncs.c http.c crypt_freesec.c \
+                            crypt_blowfish.c crypt_sha512.c crypt_sha256.c php_crypt_r.c)
 
 PHP_ADD_MAKEFILE_FRAGMENT
 PHP_INSTALL_HEADERS([ext/standard/])
diff --git a/ext/standard/crypt.c b/ext/standard/crypt.c
index 526c792..c6e0351 100644
--- a/ext/standard/crypt.c
+++ b/ext/standard/crypt.c
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2010 The PHP Group                                |
+   | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -15,23 +15,30 @@
    | Authors: Stig Bakken <ssb@php.net>                                   |
    |          Zeev Suraski <zeev@zend.com>                                |
    |          Rasmus Lerdorf <rasmus@php.net>                             |
+   |          Pierre Joye <pierre@php.net>                                |
    +----------------------------------------------------------------------+
- */
-/* $Id: crypt.c 293036 2010-01-03 09:23:27Z sebastian $ */
+*/
+
+/* $Id$ */
+
 #include <stdlib.h>
 
 #include "php.h"
-
 #if HAVE_CRYPT
 
 #if HAVE_UNISTD_H
 #include <unistd.h>
 #endif
-#if HAVE_CRYPT_H
-#if defined(CRYPT_R_GNU_SOURCE) && !defined(_GNU_SOURCE)
-#define _GNU_SOURCE
-#endif
-#include <crypt.h>
+#if PHP_USE_PHP_CRYPT_R
+# include "php_crypt_r.h"
+# include "crypt_freesec.h"
+#else
+# if HAVE_CRYPT_H
+#  if defined(CRYPT_R_GNU_SOURCE) && !defined(_GNU_SOURCE)
+#   define _GNU_SOURCE
+#  endif
+#  include <crypt.h>
+# endif
 #endif
 #if TM_IN_SYS_TIME
 #include <sys/time.h>
@@ -46,19 +53,17 @@
 
 #ifdef PHP_WIN32
 #include <process.h>
-extern char *crypt(char *__key, char *__salt);
 #endif
 
 #include "php_lcg.h"
 #include "php_crypt.h"
 #include "php_rand.h"
 
-/* 
-   The capabilities of the crypt() function is determined by the test programs
-   run by configure from aclocal.m4.  They will set PHP_STD_DES_CRYPT,
-   PHP_EXT_DES_CRYPT, PHP_MD5_CRYPT and PHP_BLOWFISH_CRYPT as appropriate 
-   for the target platform
-*/
+/* The capabilities of the crypt() function is determined by the test programs
+ * run by configure from aclocal.m4.  They will set PHP_STD_DES_CRYPT,
+ * PHP_EXT_DES_CRYPT, PHP_MD5_CRYPT and PHP_BLOWFISH_CRYPT as appropriate
+ * for the target platform. */
+
 #if PHP_STD_DES_CRYPT
 #define PHP_MAX_SALT_LEN 2
 #endif
@@ -78,10 +83,14 @@ extern char *crypt(char *__key, char *__salt);
 #define PHP_MAX_SALT_LEN 60
 #endif
 
- /*
-  * If the configure-time checks fail, we provide DES.
-  * XXX: This is a hack. Fix the real problem
-  */
+#if PHP_SHA512_CRYPT
+#undef PHP_MAX_SALT_LEN
+#define PHP_MAX_SALT_LEN 123
+#endif
+
+
+/* If the configure-time checks fail, we provide DES.
+ * XXX: This is a hack. Fix the real problem! */
 
 #ifndef PHP_MAX_SALT_LEN
 #define PHP_MAX_SALT_LEN 2
@@ -89,10 +98,9 @@ extern char *crypt(char *__key, char *__salt);
 #define PHP_STD_DES_CRYPT 1
 #endif
 
-
 #define PHP_CRYPT_RAND php_rand(TSRMLS_C)
 
-PHP_MINIT_FUNCTION(crypt)
+PHP_MINIT_FUNCTION(crypt) /* {{{ */
 {
 	REGISTER_LONG_CONSTANT("CRYPT_SALT_LENGTH", PHP_MAX_SALT_LEN, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("CRYPT_STD_DES", PHP_STD_DES_CRYPT, CONST_CS | CONST_PERSISTENT);
@@ -100,35 +108,58 @@ PHP_MINIT_FUNCTION(crypt)
 	REGISTER_LONG_CONSTANT("CRYPT_MD5", PHP_MD5_CRYPT, CONST_CS | CONST_PERSISTENT);
 	REGISTER_LONG_CONSTANT("CRYPT_BLOWFISH", PHP_BLOWFISH_CRYPT, CONST_CS | CONST_PERSISTENT);
 
+#ifdef PHP_SHA256_CRYPT
+   REGISTER_LONG_CONSTANT("CRYPT_SHA256", PHP_SHA256_CRYPT, CONST_CS | CONST_PERSISTENT);
+#endif
+
+#ifdef PHP_SHA512_CRYPT
+   REGISTER_LONG_CONSTANT("CRYPT_SHA512", PHP_SHA512_CRYPT, CONST_CS | CONST_PERSISTENT);
+#endif
+
+#if PHP_USE_PHP_CRYPT_R
+	php_init_crypt_r();
+#endif
+
 	return SUCCESS;
 }
+/* }}} */
+
+PHP_MSHUTDOWN_FUNCTION(crypt) /* {{{ */
+{
+#if PHP_USE_PHP_CRYPT_R
+	php_shutdown_crypt_r();
+#endif
 
+	return SUCCESS;
+}
+/* }}} */
 
 static unsigned char itoa64[] = "./0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
 
-static void php_to64(char *s, long v, int n)
+static void php_to64(char *s, long v, int n) /* {{{ */
 {
 	while (--n >= 0) {
-		*s++ = itoa64[v&0x3f]; 		
+		*s++ = itoa64[v&0x3f];
 		v >>= 6;
-	} 
-} 
+	}
+}
+/* }}} */
 
 /* {{{ proto string crypt(string str [, string salt])
-   Encrypt a string */
+   Hash a string */
 PHP_FUNCTION(crypt)
 {
-	char salt[PHP_MAX_SALT_LEN+1];
+	char salt[PHP_MAX_SALT_LEN + 1];
 	char *str, *salt_in = NULL;
-	int str_len, salt_in_len;
+	int str_len, salt_in_len = 0;
+	char *crypt_res;
+	salt[0] = salt[PHP_MAX_SALT_LEN] = '\0';
 
-	salt[0]=salt[PHP_MAX_SALT_LEN]='\0';
 	/* This will produce suitable results if people depend on DES-encryption
-	   available (passing always 2-character salt). At least for glibc6.1 */
-	memset(&salt[1], '$', PHP_MAX_SALT_LEN-1);
+	 * available (passing always 2-character salt). At least for glibc6.1 */
+	memset(&salt[1], '$', PHP_MAX_SALT_LEN - 1);
 
-	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &str, &str_len,
-							  &salt_in, &salt_in_len) == FAILURE) {
+	if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, "s|s", &str, &str_len, &salt_in, &salt_in_len) == FAILURE) {
 		return;
 	}
 
@@ -136,33 +167,142 @@ PHP_FUNCTION(crypt)
 		memcpy(salt, salt_in, MIN(PHP_MAX_SALT_LEN, salt_in_len));
 	}
 
-	/* The automatic salt generation only covers standard DES and md5-crypt */
-	if(!*salt) {
+	/* The automatic salt generation covers standard DES, md5-crypt and Blowfish (simple) */
+	if (!*salt) {
 #if PHP_MD5_CRYPT
-		strcpy(salt, "$1$");
+		strncpy(salt, "$1$", PHP_MAX_SALT_LEN);
 		php_to64(&salt[3], PHP_CRYPT_RAND, 4);
 		php_to64(&salt[7], PHP_CRYPT_RAND, 4);
-		strcpy(&salt[11], "$");
+		strncpy(&salt[11], "$", PHP_MAX_SALT_LEN - 11);
 #elif PHP_STD_DES_CRYPT
 		php_to64(&salt[0], PHP_CRYPT_RAND, 2);
 		salt[2] = '\0';
 #endif
+		salt_in_len = strlen(salt);
+	} else {
+		salt_in_len = MIN(PHP_MAX_SALT_LEN, salt_in_len);
+	}
+
+/* Windows (win32/crypt) has a stripped down version of libxcrypt and 
+	a CryptoApi md5_crypt implementation */
+#if PHP_USE_PHP_CRYPT_R
+	{
+		struct php_crypt_extended_data buffer;
+
+		if (salt[0]=='$' && salt[1]=='1' && salt[2]=='$') {
+			char output[MD5_HASH_MAX_LEN];
+
+			RETURN_STRING(php_md5_crypt_r(str, salt, output), 1);
+		} else if (salt[0]=='$' && salt[1]=='6' && salt[2]=='$') {
+			const char sha512_salt_prefix[] = "$6$";
+			const char sha512_rounds_prefix[] = "rounds=";
+			char *output;
+			int needed = (sizeof(sha512_salt_prefix) - 1
+						+ sizeof(sha512_rounds_prefix) + 9 + 1
+						+ salt_in_len + 1 + 86 + 1);
+			output = emalloc(needed);
+			salt[salt_in_len] = '\0';
+
+			crypt_res = php_sha512_crypt_r(str, salt, output, needed);
+			if (!crypt_res) {
+				if (salt[0]=='*' && salt[1]=='0') {
+					RETVAL_STRING("*1", 1);
+				} else {
+					RETVAL_STRING("*0", 1);
+				}
+			} else {
+				RETVAL_STRING(output, 1);
+			}
+
+			memset(output, 0, needed);
+			efree(output);
+		} else if (salt[0]=='$' && salt[1]=='5' && salt[2]=='$') {
+			const char sha256_salt_prefix[] = "$5$";
+			const char sha256_rounds_prefix[] = "rounds=";
+			char *output;
+			int needed = (sizeof(sha256_salt_prefix) - 1
+						+ sizeof(sha256_rounds_prefix) + 9 + 1
+						+ salt_in_len + 1 + 43 + 1);
+			output = emalloc(needed);
+			salt[salt_in_len] = '\0';
+
+			crypt_res = php_sha256_crypt_r(str, salt, output, needed);
+			if (!crypt_res) {
+				if (salt[0]=='*' && salt[1]=='0') {
+					RETVAL_STRING("*1", 1);
+				} else {
+					RETVAL_STRING("*0", 1);
+				}
+			} else {
+				RETVAL_STRING(output, 1);
+			}
+
+			memset(output, 0, needed);
+			efree(output);
+		} else if (
+				salt[0] == '$' &&
+				salt[1] == '2' &&
+				salt[2] >= 'a' && salt[2] <= 'z' &&
+				salt[3] == '$' &&
+				salt[4] >= '0' && salt[4] <= '3' &&
+				salt[5] >= '0' && salt[5] <= '9' &&
+				salt[6] == '$') {
+			char output[PHP_MAX_SALT_LEN + 1];
+
+			memset(output, 0, PHP_MAX_SALT_LEN + 1);
+
+			crypt_res = php_crypt_blowfish_rn(str, salt, output, sizeof(output));
+			if (!crypt_res) {
+				if (salt[0]=='*' && salt[1]=='0') {
+					RETVAL_STRING("*1", 1);
+				} else {
+					RETVAL_STRING("*0", 1);
+				}
+			} else {
+				RETVAL_STRING(output, 1);
+			}
+
+			memset(output, 0, PHP_MAX_SALT_LEN + 1);
+		} else {
+			memset(&buffer, 0, sizeof(buffer));
+			_crypt_extended_init_r();
+
+			crypt_res = _crypt_extended_r(str, salt, &buffer);
+			if (!crypt_res) {
+				if (salt[0]=='*' && salt[1]=='0') {
+					RETURN_STRING("*1", 1);
+				} else {
+					RETURN_STRING("*0", 1);
+				}
+			} else {
+				RETURN_STRING(crypt_res, 1);
+			}
+		}
 	}
-#if defined(HAVE_CRYPT_R) && (defined(_REENTRANT) || defined(_THREAD_SAFE))
+#else
+
+# if defined(HAVE_CRYPT_R) && (defined(_REENTRANT) || defined(_THREAD_SAFE))
 	{
-#if defined(CRYPT_R_STRUCT_CRYPT_DATA)
+#  if defined(CRYPT_R_STRUCT_CRYPT_DATA)
 		struct crypt_data buffer;
 		memset(&buffer, 0, sizeof(buffer));
-#elif defined(CRYPT_R_CRYPTD)
+#  elif defined(CRYPT_R_CRYPTD)
 		CRYPTD buffer;
-#else 
-#error Data struct used by crypt_r() is unknown. Please report.
-#endif
-
-		RETURN_STRING(crypt_r(str, salt, &buffer), 1);
+#  else
+#    error Data struct used by crypt_r() is unknown. Please report.
+#  endif
+		crypt_res = crypt_r(str, salt, &buffer);
+		if (!crypt_res) {
+				if (salt[0]=='*' && salt[1]=='0') {
+					RETURN_STRING("*1", 1);
+				} else {
+					RETURN_STRING("*0", 1);
+				}
+		} else {
+			RETURN_STRING(crypt_res, 1);
+		}
 	}
-#else
-	RETURN_STRING(crypt(str, salt), 1);
+# endif
 #endif
 }
 /* }}} */
diff --git a/ext/standard/php_crypt.h b/ext/standard/php_crypt.h
index 5359cf1..47d7837 100644
--- a/ext/standard/php_crypt.h
+++ b/ext/standard/php_crypt.h
@@ -2,7 +2,7 @@
    +----------------------------------------------------------------------+
    | PHP Version 5                                                        |
    +----------------------------------------------------------------------+
-   | Copyright (c) 1997-2010 The PHP Group                                |
+   | Copyright (c) 1997-2013 The PHP Group                                |
    +----------------------------------------------------------------------+
    | This source file is subject to version 3.01 of the PHP license,      |
    | that is bundled with this package in the file LICENSE, and is        |
@@ -18,7 +18,7 @@
    +----------------------------------------------------------------------+
 */
 
-/* $Id: php_crypt.h 293036 2010-01-03 09:23:27Z sebastian $ */
+/* $Id$ */
 
 #ifndef PHP_CRYPT_H
 #define PHP_CRYPT_H
@@ -26,6 +26,7 @@
 PHP_FUNCTION(crypt);
 #if HAVE_CRYPT
 PHP_MINIT_FUNCTION(crypt);
+PHP_MSHUTDOWN_FUNCTION(crypt);
 PHP_RINIT_FUNCTION(crypt);
 #endif
 
